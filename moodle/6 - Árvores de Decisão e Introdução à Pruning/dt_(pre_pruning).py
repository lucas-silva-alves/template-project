# -*- coding: utf-8 -*-
"""DT (Pre-pruning).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/138LmdV5r14NNEOW0om9U5cWFqb_lF6HC

# Pre-pruning (pré-poda) em Árvores de Decisão
Prof. Dr. Tiago Oliveira Weber

## Sem ruído e Sem pré-pruning
Inicialmente, uma versão sem ruído na base para o caso da porta lógica AND.
"""

from sklearn import tree
import numpy as np

#X = [[0, 0, 0], [0, 1, 1], [1, 0, 0], [1, 1, 0], [1, 1, 1]]
#Y = [0, 1, 1, 0, 1]

#X = [[0, 0], [0, 1], [1, 0], [1, 1], [1, 1]]
#X = np.array(X)

#Y = [0, 1, 1, 0]
#Y = np.array(Y)

#ipdb.set_trace()
X = np.random.random([500,2])
Y = []
for x_value in X:
    y_value = 0
    if (x_value[0] > 0.5) and (x_value[1] > 0.5):  # AND "logic"
        y_value = 1

    #random part
    #if np.random.random() > 0.9:
    #    y_value = not y_value

    Y.append(y_value)

Y = np.array(Y)

feature_names = ['x1','x2']
target_names = ['falso','verdadeiro']


clf = tree.DecisionTreeClassifier()
#clf = tree.DecisionTreeClassifier(max_depth=2)
#clf = tree.DecisionTreeClassifier(min_samples_split=200)
#clf = tree.DecisionTreeClassifier(min_samples_leaf=100)
#clf = tree.DecisionTreeClassifier(criterion='gini',min_impurity_decrease=0.01)

clf = clf.fit(X, Y)

# predicting for a specific input
# clf.predict([[1., 1.,]])

# plot directly (did not work)
# tree.plot_tree(clf)

# export in graphical format
import graphviz
dot_data = tree.export_graphviz(clf, out_file=None, filled=False, rounded=True, impurity=True,
class_names=target_names,
                                feature_names=feature_names
)

graph = graphviz.Source(dot_data)
graph.render("graph")

# export in text format
r = tree.export_text(clf)
print('\n'+r)

"""## Com ruído e Sem poda"""

from sklearn import tree
import numpy as np

#X = [[0, 0, 0], [0, 1, 1], [1, 0, 0], [1, 1, 0], [1, 1, 1]]
#Y = [0, 1, 1, 0, 1]

#X = [[0, 0], [0, 1], [1, 0], [1, 1], [1, 1]]
#X = np.array(X)

#Y = [0, 1, 1, 0]
#Y = np.array(Y)

#ipdb.set_trace()
X = np.random.random([500,2])
Y = []
for x_value in X:
    y_value = 0
    if (x_value[0] > 0.5) and (x_value[1] > 0.5):  # AND "logic"
        y_value = 1

    #random part
    if np.random.random() > 0.9:
        y_value = not y_value

    Y.append(y_value)

Y = np.array(Y)

feature_names = ['x1','x2']
target_names = ['falso','verdadeiro']


clf = tree.DecisionTreeClassifier()
#clf = tree.DecisionTreeClassifier(max_depth=2)
#clf = tree.DecisionTreeClassifier(min_samples_split=200)
#clf = tree.DecisionTreeClassifier(min_samples_leaf=100)
#clf = tree.DecisionTreeClassifier(criterion='gini',min_impurity_decrease=0.01)

clf = clf.fit(X, Y)

# predicting for a specific input
# clf.predict([[1., 1.,]])

# plot directly (did not work)
# tree.plot_tree(clf)

# export in graphical format
import graphviz
dot_data = tree.export_graphviz(clf, out_file=None, filled=False, rounded=True, impurity=True,
class_names=target_names,
                                feature_names=feature_names
)

graph = graphviz.Source(dot_data)
graph.render("graph")

# export in text format
r = tree.export_text(clf)
print('\n'+r)

"""## Com Ruído e Com Poda"""

from sklearn import tree
import numpy as np

#X = [[0, 0, 0], [0, 1, 1], [1, 0, 0], [1, 1, 0], [1, 1, 1]]
#Y = [0, 1, 1, 0, 1]

#X = [[0, 0], [0, 1], [1, 0], [1, 1], [1, 1]]
#X = np.array(X)

#Y = [0, 1, 1, 0]
#Y = np.array(Y)

#ipdb.set_trace()
X = np.random.random([500,2])
Y = []
for x_value in X:
    y_value = 0
    if (x_value[0] > 0.5) and (x_value[1] > 0.5):  # AND "logic"
        y_value = 1

    #random part
    if np.random.random() > 0.9:
        y_value = not y_value

    Y.append(y_value)

Y = np.array(Y)

feature_names = ['x1','x2']
target_names = ['falso','verdadeiro']


#clf = tree.DecisionTreeClassifier()
#clf = tree.DecisionTreeClassifier(max_depth=2)
#clf = tree.DecisionTreeClassifier(min_samples_split=200)
#clf = tree.DecisionTreeClassifier(min_samples_leaf=100)
clf = tree.DecisionTreeClassifier(criterion='gini',min_impurity_decrease=0.01)

clf = clf.fit(X, Y)

# predicting for a specific input
# clf.predict([[1., 1.,]])

# plot directly (did not work)
# tree.plot_tree(clf)

# export in graphical format
import graphviz
dot_data = tree.export_graphviz(clf, out_file=None, filled=False, rounded=True, impurity=True,
class_names=target_names,
                                feature_names=feature_names
)

graph = graphviz.Source(dot_data)
graph.render("graph")

# export in text format
r = tree.export_text(clf)
print('\n'+r)